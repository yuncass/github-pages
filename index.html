<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>세대 출력 (입력 폼 + 구성원 정렬 + 이름 3글자 앵커 + 간격 우선/폰트 축소 후순위)</title>

  <style>
    @page { size: 100mm 200mm; margin: 0; }

    :root{
      --paper-w: 100mm;
      --paper-h: 200mm;

      /* 글씨 영역 고정 박스: (18,70)에서 (65,120) */
      --content-x: 18mm;
      --content-y: 70mm;
      --content-w: 65mm;
      --content-h: 120mm;

      /* page별 JS 프리셋이 덮어씀 */
      --member-font: 8.2mm;
      --member-gap: 2.6mm;
      --members-side-pad: 1.2mm;
      --members-addr-gap: 3.0mm;

      --addr-w: 20mm;
      --addr-font: 6.2mm;

      /* 세로 간격 자동(픽셀) */
      --member-body-h-px: 300px;
      --char-gap-px: 4px;
      --small-gap-px: 4px;
      --mid-gap-px: 18px;

      /* 이름 블록: 3글자 기준 앵커(고정 높이) */
      --name-block-h-px: 120px;

      /* 이름이 길어져도: 1) 간격 축소 먼저 2) 그래도 부족하면 폰트 축소 */
      --text-scale: 1;

      --stack-line: 1.0;
      --min-member-font: 5.4mm;
      --min-addr-font: 4.2mm;
    }

    html, body { height: 100%; }
    body{
      margin: 0;
      background:#f2f2f2;
      color:#000;
      font-family: "궁서", "Gungsuh", serif;
    }

    /* -------------------- 상단 UI -------------------- */
    .controls{
      padding:12px;
      background:#fafafa;
      border-bottom:1px solid #ddd;
      display:flex;
      flex-direction:column;
      gap:10px;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }

    .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .row input[type="text"]{ width:min(520px, 100%); padding:8px; }
    .row button{ padding:8px 12px; }

    .hint{ font-size:12px; color:#333; line-height:1.4; }
    .muted{ color:#666; font-size:12px; }

    details{
      border:1px solid #e3e3e3;
      border-radius:10px;
      background:#fff;
      padding:10px;
    }
    summary{ cursor:pointer; font-weight:600; }

    .editor{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:10px;
    }

    .genCard{
      border:1px solid #e7e7e7;
      border-radius:12px;
      padding:10px;
      background:#fff;
    }

    .genHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 2fr;
      gap:8px;
      align-items:center;
    }
    .grid2 label{ font-size:12px; color:#333; }
    .grid2 input{ padding:8px; width:100%; }

    .membersTable{
      width:100%;
      border-collapse:collapse;
      margin-top:10px;
    }
    .membersTable th, .membersTable td{
      border-bottom:1px solid #eee;
      padding:6px;
      font-size:12px;
      vertical-align:middle;
    }
    .membersTable input{
      width:100%;
      padding:6px;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }

    .smallBtn{ padding:6px 10px; font-size:12px; }
    .danger{ background:#fff0f0; border:1px solid #ffd0d0; }

    textarea{
      width:100%;
      min-height:180px;
      padding:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      border:1px solid #e7e7e7;
      border-radius:10px;
      box-sizing:border-box;
    }

    /* 드래그/정렬 UI */
    .dragHandle{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 8px;
      border:1px solid #ddd;
      border-radius:8px;
      cursor:grab;
      user-select:none;
      background:#fff;
    }
    .dragHandle:active{ cursor:grabbing; }
    .dragOverRow{
      outline: 2px dashed #bbb;
      outline-offset: 2px;
    }
    .orderBtns{
      display:inline-flex;
      gap:6px;
      margin-left:6px;
    }

    /* -------------------- 출력 영역 -------------------- */
    .wrap{ padding:16px; display:flex; justify-content:center; }
    .pagesCol{ display:flex; flex-direction:column; align-items:center; gap:14px; }

    .page{
      width: var(--paper-w);
      height: var(--paper-h);
      background:#fff;
      box-shadow:0 6px 18px rgba(0,0,0,0.18);
      overflow:hidden;
      position:relative;

      break-inside: avoid;
      page-break-inside: avoid;
      font-family: "궁서", "Gungsuh", serif;
    }

    @media print{
      body{ background:transparent; margin:0; }
      .controls{ display:none !important; }
      .wrap{ padding:0; display:block; }
      .pagesCol{ gap:0; }
      .page{
        box-shadow:none;
        margin:0;
        break-after: page;
        page-break-after: always;
      }
      .page:last-child{
        break-after: auto;
        page-break-after: auto;
      }
    }

    .pageInner{
      position:absolute;
      left: var(--content-x);
      top:  var(--content-y);
      width: var(--content-w);
      height: var(--content-h);

      display:flex;
      gap: var(--members-addr-gap);
      align-items:flex-start;
      justify-content:flex-start;
      overflow: hidden;
    }

    .membersArea{
      position:relative;
      height: var(--content-h);
      flex: 1 1 auto;

      display:flex;
      justify-content:center;
      align-items:flex-start;
      gap: var(--member-gap);

      padding: 0 var(--members-side-pad);
      min-width: 0;
      overflow: hidden;
    }

    .memberCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      text-align:center;
      white-space:nowrap;
      font-size: var(--member-font);
      line-height: var(--stack-line);
      min-width: 0;
    }

    .memberBody{
      height: var(--member-body-h-px);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      overflow:hidden;
    }

    .stack{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--char-gap-px);
    }
    .stack .ch{
      display:block;
      line-height: 1;
    }

    /* ✅ 출생년/생/이름: 동일 비율 축소(필요 시) */
    .birth.stack,
    .saeng.stack,
    .name.stack{
      font-size: calc(var(--member-font) * var(--text-scale));
      line-height: 1;
    }

    /* ✅ 이름: 3글자 기준 앵커(첫/마지막 고정). 글자 수가 늘면 간격이 먼저 줄어듦 */
    .name.stack{
      height: var(--name-block-h-px);
      justify-content: space-between;
      gap: 0;
    }

    .smallSpacer{ height: var(--small-gap-px); }
    .midSpacer{ height: var(--mid-gap-px); }

    .location{
      position:absolute;
      left:0; right:0;
      bottom:0;
      text-align:center;
      font-size: calc(var(--member-font) * 0.75);
      letter-spacing: 0.4mm;
    }

    .addrArea{
      width: var(--addr-w);
      height: var(--content-h);

      display:flex;
      flex-direction:column;
      align-items:center;

      flex: 0 0 auto;
      overflow: hidden;
    }

    /* 주소 라벨 가로 */
    .addrLabel{
      font-size: var(--member-font);
      line-height: 1.0;
      text-align:center;
      white-space:nowrap;
    }

    .addrCols{
      margin-top: 3mm;
      height: calc(var(--content-h) - 12mm);

      display:flex;
      flex-direction: row-reverse;
      gap: 2.2mm;
      align-items:flex-start;
      justify-content:center;

      min-width: 0;
      overflow: hidden;
    }

    .addrCol{
      font-size: var(--addr-font);
      line-height: 1.0;
      text-align:center;
      white-space:nowrap;
      min-width: 0;
    }
  </style>
</head>

<body>
  <div class="controls">
    <details open>
      <summary>세대 입력 폼 (구성원 드래그 정렬 포함)</summary>
      <div class="hint" style="margin-top:6px">
        - 세대는 여러 개 추가 가능하며, 인쇄 시 세대당 1페이지입니다.<br/>
        - 구성원은 최대 7명까지 입력됩니다.<br/>
        - 요구사항에 따라 <b>출력은 입력 순서를 역순으로 배치</b>합니다. (입력은 자연스러운 순서로 작성)
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="btnAddGen" type="button">세대 추가</button>
        <button id="btnRender" type="button">미리보기 갱신</button>
        <button id="btnPrint" type="button">인쇄</button>
        <span class="muted" id="status"></span>
      </div>

      <div id="editor" class="editor"></div>
    </details>

    <details>
      <summary>JSON 가져오기 / 내보내기</summary>

      <div class="row" style="margin-top:10px;">
        <input id="file" type="file" accept=".json,application/json" />
        <input id="url" type="text" placeholder="JSON URL (또는 ?src= 로 자동 로드)" />
        <button id="btnLoadUrl" type="button">URL 불러오기</button>
      </div>

      <div class="row">
        <button id="btnExportJson" type="button">현재 입력을 JSON으로 생성</button>
        <button id="btnCopyJson" type="button">JSON 복사</button>
        <button id="btnDownloadJson" type="button">JSON 다운로드</button>
        <button id="btnLoadSample" type="button">샘플 로드</button>
      </div>

      <div class="hint">
        - JSON 복사는 브라우저 정책상 HTTPS 환경에서만 동작할 수 있습니다.
      </div>

      <textarea id="jsonOut" spellcheck="false" placeholder="여기에 JSON이 표시됩니다."></textarea>
    </details>
  </div>

  <div class="wrap">
    <div class="pagesCol" id="pages"></div>
  </div>

  <script>
    const pagesEl = document.getElementById('pages');
    const editorEl = document.getElementById('editor');
    const statusEl = document.getElementById('status');
    const jsonOutEl = document.getElementById('jsonOut');

    const fileEl  = document.getElementById('file');
    const urlEl   = document.getElementById('url');

    // -----------------------------
    // 상태(폼 입력값)
    // -----------------------------
    const state = { gens: [] };

    function defaultGen(){
      return {
        위치: "",
        주소: "",
        구성원: [{ 이름: "", 출생년: "" }]
      };
    }

    function setStatus(msg){
      statusEl.textContent = msg || "";
    }

    // -----------------------------
    // 유틸
    // -----------------------------
    function clampInt(v, min, max){ v = Math.floor(v); return Math.max(min, Math.min(max, v)); }
    function escapeHtml(s){
      return String(s)
        .replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
        .replaceAll('"','&quot;').replaceAll("'","&#39;");
    }
    function toChars(str){ return Array.from(String(str ?? '').trim()); }
    function padLines(chars, targetLen){
      const out = chars.slice();
      while(out.length < targetLen) out.push('');
      return out;
    }
    function stackSpansFromLines(lines){
      // 빈 줄은 전각공백으로 높이 유지
      return lines.map(ch => `<span class="ch">${ch ? escapeHtml(ch) : '　'}</span>`).join('');
    }

    // -----------------------------
    // 구성원 순서 이동/정렬
    // -----------------------------
    function moveMember(gi, fromIndex, toIndex){
      const gen = state.gens[gi];
      if (!gen || !Array.isArray(gen.구성원)) return;

      const arr = gen.구성원;
      const n = arr.length;

      if (fromIndex < 0 || fromIndex >= n) return;

      // 허용 범위: 0..n (n은 맨 끝 삽입)
      if (toIndex < 0) toIndex = 0;
      if (toIndex > n) toIndex = n;

      const [item] = arr.splice(fromIndex, 1);

      // 제거 후 인덱스 보정
      if (fromIndex < toIndex) toIndex -= 1;

      arr.splice(toIndex, 0, item);
    }

    // -----------------------------
    // 입력 폼 렌더링
    // -----------------------------
    function renderEditor(){
      editorEl.innerHTML = '';

      if (state.gens.length === 0){
        state.gens.push(defaultGen());
      }

      state.gens.forEach((gen, gi) => {
        const card = document.createElement('div');
        card.className = 'genCard';

        const header = document.createElement('div');
        header.className = 'genHeader';
        header.innerHTML = `
          <div><b>세대 ${gi+1}</b> <span class="muted">(인쇄 시 ${gi+1}페이지)</span></div>
          <div class="row">
            <button class="smallBtn danger" type="button" data-act="removeGen" data-gi="${gi}">세대 삭제</button>
          </div>
        `;

        const form = document.createElement('div');
        form.className = 'grid2';
        form.innerHTML = `
          <label>위치</label>
          <input type="text" value="${escapeHtml(gen.위치 ?? '')}" placeholder="예: 5-10"
                 data-act="setField" data-gi="${gi}" data-field="위치" />

          <label>주소</label>
          <input type="text" value="${escapeHtml(gen.주소 ?? '')}" placeholder="예: 삼성의로 평택시 독곡동 102의 905 468"
                 data-act="setField" data-gi="${gi}" data-field="주소" />
        `;

        const membersTitle = document.createElement('div');
        membersTitle.className = 'row';
        membersTitle.style.marginTop = "10px";
        membersTitle.innerHTML = `
          <b>구성원</b>
          <span class="muted">(최대 7명, 드래그/▲▼로 순서 변경)</span>
          <button class="smallBtn" type="button" data-act="addMember" data-gi="${gi}">구성원 추가</button>
        `;

        const table = document.createElement('table');
        table.className = 'membersTable';
        table.innerHTML = `
          <thead>
            <tr>
              <th style="width:22%">순서</th>
              <th style="width:40%">이름</th>
              <th style="width:28%">출생년</th>
              <th style="width:10%"></th>
            </tr>
          </thead>
          <tbody data-gi="${gi}"></tbody>
        `;

        const tbody = table.querySelector('tbody');

        const members = Array.isArray(gen.구성원) ? gen.구성원 : [];
        members.forEach((m, mi) => {
          const tr = document.createElement('tr');
          tr.dataset.gi = String(gi);
          tr.dataset.mi = String(mi);

          const isFirst = mi === 0;
          const isLast = mi === members.length - 1;

          tr.innerHTML = `
            <td>
              <span class="dragHandle" draggable="true"
                    data-act="dragHandle" data-gi="${gi}" data-mi="${mi}"
                    title="드래그하여 순서 변경">≡</span>
              <span class="orderBtns">
                <button class="smallBtn" type="button"
                        data-act="moveMemberUp" data-gi="${gi}" data-mi="${mi}"
                        ${isFirst ? 'disabled' : ''} title="위로">▲</button>
                <button class="smallBtn" type="button"
                        data-act="moveMemberDown" data-gi="${gi}" data-mi="${mi}"
                        ${isLast ? 'disabled' : ''} title="아래로">▼</button>
              </span>
            </td>

            <td>
              <input type="text" value="${escapeHtml(m?.이름 ?? '')}" placeholder="예: 이동근"
                     data-act="setMember" data-gi="${gi}" data-mi="${mi}" data-field="이름" />
            </td>

            <td>
              <input type="text" value="${escapeHtml(m?.출생년 ?? '')}" placeholder="예: 정을"
                     data-act="setMember" data-gi="${gi}" data-mi="${mi}" data-field="출생년" />
            </td>

            <td style="text-align:right">
              <button class="smallBtn danger" type="button"
                      data-act="removeMember" data-gi="${gi}" data-mi="${mi}">
                삭제
              </button>
            </td>
          `;
          tbody.appendChild(tr);
        });

        card.appendChild(header);
        card.appendChild(form);
        card.appendChild(membersTitle);
        card.appendChild(table);

        editorEl.appendChild(card);

        const addBtn = card.querySelector('[data-act="addMember"]');
        if (members.length >= 7) addBtn.disabled = true;
      });

      updateJsonOut();
    }

    // -----------------------------
    // 입력 이벤트 (클릭/입력)
    // -----------------------------
    editorEl.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-act]');
      if (!btn) return;

      const act = btn.dataset.act;
      const gi = parseInt(btn.dataset.gi || '-1', 10);

      if (act === 'removeGen'){
        if (state.gens.length <= 1) {
          state.gens[0] = defaultGen();
        } else {
          state.gens.splice(gi, 1);
        }
        renderEditor();
        scheduleRender();
        return;
      }

      if (act === 'addMember'){
        const gen = state.gens[gi];
        if (!gen) return;
        if (!Array.isArray(gen.구성원)) gen.구성원 = [];
        if (gen.구성원.length >= 7) return;
        gen.구성원.push({이름:"", 출생년:""});
        renderEditor();
        scheduleRender();
        return;
      }

      if (act === 'removeMember'){
        const mi = parseInt(btn.dataset.mi || '-1', 10);
        const gen = state.gens[gi];
        if (!gen || !Array.isArray(gen.구성원)) return;
        gen.구성원.splice(mi, 1);
        if (gen.구성원.length === 0) gen.구성원.push({이름:"", 출생년:""});
        renderEditor();
        scheduleRender();
        return;
      }

      if (act === 'moveMemberUp'){
        const mi = parseInt(btn.dataset.mi || '-1', 10);
        if (mi > 0){
          moveMember(gi, mi, mi - 1);
          renderEditor();
          scheduleRender();
        }
        return;
      }

      if (act === 'moveMemberDown'){
        const mi = parseInt(btn.dataset.mi || '-1', 10);
        const gen = state.gens[gi];
        const n = Array.isArray(gen?.구성원) ? gen.구성원.length : 0;
        if (mi >= 0 && mi < n - 1){
          moveMember(gi, mi, mi + 2);
          renderEditor();
          scheduleRender();
        }
        return;
      }
    });

    editorEl.addEventListener('input', (e) => {
      const el = e.target.closest('[data-act]');
      if (!el) return;

      const act = el.dataset.act;
      const gi = parseInt(el.dataset.gi || '-1', 10);

      if (act === 'setField'){
        const field = el.dataset.field;
        if (!state.gens[gi]) return;
        state.gens[gi][field] = el.value;
        updateJsonOut();
        scheduleRender();
        return;
      }

      if (act === 'setMember'){
        const mi = parseInt(el.dataset.mi || '-1', 10);
        const field = el.dataset.field;
        const gen = state.gens[gi];
        if (!gen) return;
        if (!Array.isArray(gen.구성원)) gen.구성원 = [];
        if (!gen.구성원[mi]) gen.구성원[mi] = {이름:"", 출생년:""};
        gen.구성원[mi][field] = el.value;
        updateJsonOut();
        scheduleRender();
        return;
      }
    });

    document.getElementById('btnAddGen').addEventListener('click', () => {
      state.gens.push(defaultGen());
      renderEditor();
      scheduleRender();
    });

    document.getElementById('btnRender').addEventListener('click', () => {
      renderFromState();
    });

    document.getElementById('btnPrint').addEventListener('click', () => window.print());

    // -----------------------------
    // 드래그 앤 드롭(구성원 순서 변경)
    // -----------------------------
    let dragPayload = null; // {gi, mi}

    editorEl.addEventListener('dragstart', (e) => {
      const handle = e.target.closest('.dragHandle');
      if (!handle) return;

      const gi = parseInt(handle.dataset.gi || '-1', 10);
      const mi = parseInt(handle.dataset.mi || '-1', 10);
      if (gi < 0 || mi < 0) return;

      dragPayload = { gi, mi };

      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', JSON.stringify(dragPayload));
    });

    function clearDragOver(){
      editorEl.querySelectorAll('.dragOverRow').forEach(el => el.classList.remove('dragOverRow'));
    }

    editorEl.addEventListener('dragover', (e) => {
      const row = e.target.closest('tr[data-gi][data-mi]');
      const tbody = e.target.closest('tbody[data-gi]');
      if (row || tbody) e.preventDefault();

      if (!dragPayload) return;

      clearDragOver();
      if (row){
        const gi = parseInt(row.dataset.gi || '-1', 10);
        if (gi === dragPayload.gi) row.classList.add('dragOverRow');
      }
    });

    editorEl.addEventListener('dragleave', (e) => {
      const row = e.target.closest('tr[data-gi][data-mi]');
      if (!row) return;
      row.classList.remove('dragOverRow');
    });

    editorEl.addEventListener('drop', (e) => {
      const row = e.target.closest('tr[data-gi][data-mi]');
      const tbody = e.target.closest('tbody[data-gi]');
      if (!row && !tbody) return;

      e.preventDefault();
      clearDragOver();

      let payload = dragPayload;
      try{
        const t = e.dataTransfer.getData('text/plain');
        if (t) payload = JSON.parse(t);
      }catch{}

      if (!payload) return;

      const giTarget = row
        ? parseInt(row.dataset.gi || '-1', 10)
        : parseInt(tbody.dataset.gi || '-1', 10);

      if (giTarget < 0 || payload.gi !== giTarget) {
        dragPayload = null;
        return;
      }

      let insertIndex = null;

      if (row){
        const toMi = parseInt(row.dataset.mi || '-1', 10);
        if (toMi < 0) { dragPayload = null; return; }

        const rect = row.getBoundingClientRect();
        const after = (e.clientY - rect.top) > rect.height / 2;
        insertIndex = toMi + (after ? 1 : 0);
      } else {
        const gen = state.gens[payload.gi];
        const n = Array.isArray(gen?.구성원) ? gen.구성원.length : 0;
        insertIndex = n;
      }

      moveMember(payload.gi, payload.mi, insertIndex);
      dragPayload = null;

      renderEditor();
      scheduleRender();
    });

    editorEl.addEventListener('dragend', () => {
      dragPayload = null;
      clearDragOver();
    });

    // -----------------------------
    // JSON 가져오기/내보내기
    // -----------------------------
    function exportJsonObj(){
      return state.gens.map(g => ({ 세대: g }));
    }

    function updateJsonOut(){
      try{
        jsonOutEl.value = JSON.stringify(exportJsonObj(), null, 2);
      }catch{}
    }

    document.getElementById('btnExportJson').addEventListener('click', () => {
      updateJsonOut();
      setStatus("JSON 생성 완료");
      setTimeout(() => setStatus(""), 1200);
    });

    document.getElementById('btnCopyJson').addEventListener('click', async () => {
      updateJsonOut();
      const text = jsonOutEl.value;

      try{
        await navigator.clipboard.writeText(text);
        setStatus("클립보드 복사 완료");
      }catch(err){
        jsonOutEl.focus();
        jsonOutEl.select();
        setStatus("복사 실패(브라우저/HTTPS 정책). 텍스트를 선택 후 수동 복사하세요.");
      }
      setTimeout(() => setStatus(""), 2000);
    });

    document.getElementById('btnDownloadJson').addEventListener('click', () => {
      updateJsonOut();
      const blob = new Blob([jsonOutEl.value], {type: "application/json;charset=utf-8"});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "세대_데이터.json";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
      setStatus("JSON 다운로드 시작");
      setTimeout(() => setStatus(""), 1200);
    });

    document.getElementById('btnLoadSample').addEventListener('click', () => {
      const sample = [{
        "세대": {
          "위치": "5-10",
          "주소": "삼성의로 평택시 독곡동 102의 905 468",
          "구성원": [
            { "이름": "이동근", "출생년": "정을" },
            { "이름": "박연홍", "출생년": "계무" },
            { "이름": "이용기", "출생년": "축사" },
            { "이름": "정현숙", "출생년": "묘인" }
          ]
        }
      }];
      importJsonObj(sample);
      setStatus("샘플 로드 완료");
      setTimeout(() => setStatus(""), 1200);
    });

    function normalizeRoot(input){
      if (Array.isArray(input)) return input;
      if (input && Array.isArray(input.세대목록)) return input.세대목록;
      if (input) return [input];
      return [];
    }
    function pickGeneration(item){
      return item?.세대 ?? item;
    }

    function importJsonObj(obj){
      const items = normalizeRoot(obj);
      const gens = [];
      for (const item of items){
        const g = pickGeneration(item);
        if (!g) continue;
        const gen = {
          위치: String(g.위치 ?? ""),
          주소: String(g.주소 ?? ""),
          구성원: Array.isArray(g.구성원) ? g.구성원.slice(0,7).map(m => ({
            이름: String(m?.이름 ?? ""),
            출생년: String(m?.출생년 ?? "")
          })) : [{이름:"", 출생년:""}]
        };
        if (gen.구성원.length === 0) gen.구성원.push({이름:"", 출생년:""});
        gens.push(gen);
      }
      state.gens = gens.length ? gens : [defaultGen()];
      renderEditor();
      renderFromState();
    }

    async function loadFromUrl(url){
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`URL 불러오기 실패: ${res.status}`);
      return await res.json();
    }

    function loadFromFile(file){
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          try { resolve(JSON.parse(String(reader.result ?? ''))); }
          catch(e){ reject(new Error('파일 JSON 파싱 실패: ' + e.message)); }
        };
        reader.onerror = () => reject(new Error('파일 읽기 실패'));
        reader.readAsText(file, 'utf-8');
      });
    }

    fileEl.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try{
        const obj = await loadFromFile(file);
        importJsonObj(obj);
      }catch(err){
        alert(err.message);
      }
    });

    document.getElementById('btnLoadUrl').addEventListener('click', async () => {
      const url = urlEl.value.trim();
      if (!url) return;
      try{
        const obj = await loadFromUrl(url);
        importJsonObj(obj);
      }catch(err){
        alert(err.message + '\n(서버가 CORS를 허용해야 브라우저에서 직접 로드 가능합니다.)');
      }
    });

    // -----------------------------
    // 미리보기 렌더링(출력 로직)
    // -----------------------------
    function presetFor(nRaw){
      const n = clampInt(nRaw, 1, 7);
      return {
        1: { memberFont: 9.0, memberGap:3.6, sidePad:1.6, membersAddrGap:3.4, addrW:21, addrFontRatio:0.78 },
        2: { memberFont: 8.7, memberGap:3.2, sidePad:1.5, membersAddrGap:3.3, addrW:21, addrFontRatio:0.78 },
        3: { memberFont: 8.4, memberGap:2.8, sidePad:1.3, membersAddrGap:3.1, addrW:20, addrFontRatio:0.78 },
        4: { memberFont: 8.2, memberGap:2.6, sidePad:1.2, membersAddrGap:3.0, addrW:20, addrFontRatio:0.78 },
        5: { memberFont: 7.4, memberGap:2.0, sidePad:1.0, membersAddrGap:2.8, addrW:19, addrFontRatio:0.80 },
        6: { memberFont: 6.7, memberGap:1.5, sidePad:0.8, membersAddrGap:2.6, addrW:18.5, addrFontRatio:0.82 },
        7: { memberFont: 6.1, memberGap:1.2, sidePad:0.6, membersAddrGap:2.4, addrW:18, addrFontRatio:0.84 }
      }[n];
    }

    function applyPreset(pageEl, memberCount){
      const p = presetFor(memberCount);

      pageEl.dataset.baseAddrW = String(p.addrW);
      pageEl.dataset.baseMembersAddrGap = String(p.membersAddrGap);

      pageEl.style.setProperty('--member-font', p.memberFont + 'mm');
      pageEl.style.setProperty('--member-gap', p.memberGap + 'mm');
      pageEl.style.setProperty('--members-side-pad', p.sidePad + 'mm');
      pageEl.style.setProperty('--members-addr-gap', p.membersAddrGap + 'mm');
      pageEl.style.setProperty('--addr-w', p.addrW + 'mm');
      pageEl.style.setProperty('--addr-font', (p.memberFont * p.addrFontRatio) + 'mm');

      pageEl.style.setProperty('--text-scale', '1');
    }

    function buildMembers(membersAreaEl, members, location){
      membersAreaEl.innerHTML = '';

      // 출력은 입력의 역순 배치(원본 배열 변형 방지)
      const shown = (Array.isArray(members) ? members : []).slice(0, 7).slice().reverse();

      const births = shown.map(m => toChars(m?.출생년));
      const names  = shown.map(m => toChars(m?.이름));

      const maxBirthLen = Math.max(1, ...births.map(a => a.length || 1));
      const maxNameLen  = Math.max(1, ...names.map(a => a.length || 1));

      membersAreaEl.dataset.birthLines = String(maxBirthLen);
      membersAreaEl.dataset.nameLines  = String(maxNameLen);
      membersAreaEl.dataset.memberCount = String(shown.length);

      for (let i=0; i<shown.length; i++){
        const birthLines = padLines(births[i], maxBirthLen);
        const nameLines = (names[i] && names[i].length) ? names[i] : [''];

        const col = document.createElement('div');
        col.className = 'memberCol';

        const body = document.createElement('div');
        body.className = 'memberBody';

        const birthEl = document.createElement('div');
        birthEl.className = 'birth stack';
        birthEl.innerHTML = stackSpansFromLines(birthLines);

        const smallSpacer = document.createElement('div');
        smallSpacer.className = 'smallSpacer';

        const saengEl = document.createElement('div');
        saengEl.className = 'saeng stack';
        saengEl.innerHTML = stackSpansFromLines(['생']);

        const midSpacer = document.createElement('div');
        midSpacer.className = 'midSpacer';

        const nameEl = document.createElement('div');
        nameEl.className = 'name stack';
        nameEl.innerHTML = stackSpansFromLines(nameLines);

        body.appendChild(birthEl);
        body.appendChild(smallSpacer);
        body.appendChild(saengEl);
        body.appendChild(midSpacer);
        body.appendChild(nameEl);

        col.appendChild(body);
        membersAreaEl.appendChild(col);
      }

      const loc = document.createElement('div');
      loc.className = 'location';
      loc.textContent = location ?? '';
      membersAreaEl.appendChild(loc);
    }

    function computeMaxCharsPerAddrCol(addrColsEl){
      const h = addrColsEl.getBoundingClientRect().height;

      const probe = document.createElement('div');
      probe.className = 'addrCol';
      probe.style.position = 'absolute';
      probe.style.visibility = 'hidden';
      probe.style.left = '-9999px';
      probe.innerHTML = '가<br>가<br>가<br>가<br>가';
      addrColsEl.appendChild(probe);

      const cs = window.getComputedStyle(probe);
      const fontSize = parseFloat(cs.fontSize);
      const lineHeight = cs.lineHeight === 'normal' ? fontSize * 1.0 : parseFloat(cs.lineHeight);
      addrColsEl.removeChild(probe);

      return Math.max(1, Math.floor(h / lineHeight));
    }

    function isDigit(ch){ return ch >= '0' && ch <= '9'; }
    function isHangul(ch){
      const code = ch.codePointAt(0);
      return (code >= 0xAC00 && code <= 0xD7A3) || (code >= 0x3131 && code <= 0x318E);
    }
    function isLatin(ch){
      const code = ch.codePointAt(0);
      return (code >= 0x41 && code <= 0x5A) || (code >= 0x61 && code <= 0x7A);
    }

    // 공백 유지(연속 공백은 1개)
    function tokenizeAddress(addressRaw){
      const s = String(addressRaw ?? '').trim().replace(/\s+/g, ' ');
      const tokens = [];
      let i = 0;

      while (i < s.length){
        const ch = s[i];

        if (ch === ' '){
          if (tokens.length === 0 || tokens[tokens.length - 1] !== ' ') tokens.push(' ');
          i++;
          continue;
        }

        if (isDigit(ch)){
          let j = i;
          while (j < s.length && isDigit(s[j])) j++;
          let tok = s.slice(i, j);
          i = j;

          while (i < s.length){
            if (s[i] === '-' && i+1 < s.length && isDigit(s[i+1])){
              let k = i + 1;
              while (k < s.length && isDigit(s[k])) k++;
              tok += '-' + s.slice(i+1, k);
              i = k;
              continue;
            }
            if (s[i] === '의' && i+1 < s.length && isDigit(s[i+1])){
              let k = i + 1;
              while (k < s.length && isDigit(s[k])) k++;
              tok += '의' + s.slice(i+1, k);
              i = k;
              continue;
            }
            break;
          }

          tokens.push(tok);
          continue;
        }

        if (isHangul(ch)){
          let j = i;
          while (j < s.length && isHangul(s[j])) j++;
          tokens.push(s.slice(i, j));
          i = j;
          continue;
        }

        if (isLatin(ch)){
          let j = i;
          while (j < s.length && isLatin(s[j])) j++;
          tokens.push(s.slice(i, j));
          i = j;
          continue;
        }

        tokens.push(ch);
        i++;
      }

      return tokens.filter(t => t.length > 0);
    }

    function packTokensToColumns(tokens, maxLines){
      const cols = [];
      let cur = [];
      let remaining = maxLines;

      for (const tok of tokens){
        const chars = Array.from(tok);

        if (chars.length > maxLines){
          if (cur.length){
            cols.push(cur);
            cur = [];
            remaining = maxLines;
          }
          for (let i = 0; i < chars.length; i += maxLines){
            cols.push(chars.slice(i, i + maxLines));
          }
          remaining = maxLines;
          continue;
        }

        if (chars.length > remaining){
          if (cur.length) cols.push(cur);
          cur = [];
          remaining = maxLines;
        }

        cur.push(...chars);
        remaining -= chars.length;
      }

      if (cur.length) cols.push(cur);
      return cols;
    }

    function addrCharHtml(ch){
      if (ch === ' ') return '　';
      return escapeHtml(ch);
    }

    function buildAddressColumns(addrColsEl, addressRaw){
      addrColsEl.innerHTML = '';
      const tokens = tokenizeAddress(addressRaw);
      if (!tokens.length) return 0;

      const maxLines = computeMaxCharsPerAddrCol(addrColsEl);
      const cols = packTokensToColumns(tokens, maxLines);

      for (const colChars of cols){
        const col = document.createElement('div');
        col.className = 'addrCol';
        col.innerHTML = colChars.map(ch => `<span class="ch">${addrCharHtml(ch)}</span>`).join('<br>');
        addrColsEl.appendChild(col);
      }
      return cols.length;
    }

    function mmValueFromVar(pageEl, varName){
      const v = getComputedStyle(pageEl).getPropertyValue(varName).trim();
      return parseFloat(v.replace('mm','')) || 0;
    }
    function setMmVar(pageEl, varName, mm){
      pageEl.style.setProperty(varName, mm.toFixed(2) + 'mm');
    }

    function fitMembers(pageEl){
      const membersAreaEl = pageEl.querySelector('.membersArea');
      const minFont = mmValueFromVar(pageEl, '--min-member-font');
      let font = mmValueFromVar(pageEl, '--member-font');
      let gap  = mmValueFromVar(pageEl, '--member-gap');

      for (let k=0; k<22; k++){
        if (membersAreaEl.scrollWidth <= membersAreaEl.clientWidth + 0.5) break;
        if (font <= minFont) break;
        font -= 0.15;
        gap  = Math.max(0.8, gap - 0.10);
        setMmVar(pageEl, '--member-font', font);
        setMmVar(pageEl, '--member-gap', gap);
      }
    }

    function autoAdjustAddrWidth(pageEl, addrColCount){
      const baseAddrW = parseFloat(pageEl.dataset.baseAddrW || '20');
      const baseGap   = parseFloat(pageEl.dataset.baseMembersAddrGap || '3');

      if (addrColCount < 4) {
        pageEl.style.setProperty('--addr-w', baseAddrW + 'mm');
        pageEl.style.setProperty('--members-addr-gap', baseGap + 'mm');
        return;
      }

      const shrink = Math.min(5.0, (addrColCount - 3) * 1.2);
      const newAddrW = Math.max(14.0, baseAddrW - shrink);
      const newGap = Math.max(1.6, baseGap - shrink * 0.25);

      pageEl.style.setProperty('--addr-w', newAddrW.toFixed(2) + 'mm');
      pageEl.style.setProperty('--members-addr-gap', newGap.toFixed(2) + 'mm');
    }

    function fitAddress(pageEl, addressRaw){
      const addrColsEl = pageEl.querySelector('.addrCols');
      const minFont = mmValueFromVar(pageEl, '--min-addr-font');
      let font = mmValueFromVar(pageEl, '--addr-font');

      const maxColsGoal = 6;

      for (let k=0; k<28; k++){
        const colCount = buildAddressColumns(addrColsEl, addressRaw);

        if (colCount > maxColsGoal && font > minFont){
          font -= 0.15;
          setMmVar(pageEl, '--addr-font', font);
          continue;
        }

        if (addrColsEl.scrollWidth <= addrColsEl.clientWidth + 0.5) break;
        if (font <= minFont) break;

        font -= 0.15;
        setMmVar(pageEl, '--addr-font', font);
      }
    }

    // ✅ 핵심: 이름이 길어질 때 "간격 축소 우선", 그래도 부족하면 폰트 축소
    function tuneMemberVerticalSpacing(pageEl){
      const membersAreaEl = pageEl.querySelector('.membersArea');
      const locationEl = pageEl.querySelector('.location');
      const firstCol = pageEl.querySelector('.memberCol');
      if (!membersAreaEl || !locationEl || !firstCol) return;

      const B = Math.max(1, parseInt(membersAreaEl.dataset.birthLines || '2', 10));
      const Nraw = Math.max(1, parseInt(membersAreaEl.dataset.nameLines  || '3', 10));
      const M = Math.max(1, parseInt(membersAreaEl.dataset.memberCount || '1', 10));

      const Nanchor = 3;
      const T = (B + 1 + Nanchor);         // 출생년 B + '생' 1 + 이름앵커 3
      const D = (B + Nanchor - 1);         // (B-1) + 1 + (Nanchor-1)

      const areaH = membersAreaEl.clientHeight;
      const locH  = locationEl.offsetHeight;

      const reserve = Math.max(6, Math.round(locH * 0.35));
      const bodyH = Math.max(0, areaH - locH - reserve);

      const fontBasePx = parseFloat(getComputedStyle(firstCol).fontSize) || 16;

      // 기본 midGap 비율(유지)
      const midRatio = (M <= 4) ? 0.23 : (M <= 6 ? 0.20 : 0.18);
      let midGap = bodyH * midRatio;

      // 1) 스케일은 기본 1 (폰트 축소는 "정말 필요할 때만")
      let scale = 1;

      // midGap/scale/charGap을 함께 안정화 (몇 회만 반복)
      for (let iter = 0; iter < 8; iter++){
        const fontEff = fontBasePx * scale;

        // charGap 계산(전체 높이 맞추기)
        let charGap = (bodyH - midGap - (T * fontEff)) / D;
        if (!isFinite(charGap)) charGap = 0;
        if (charGap < 0) charGap = 0;

        // 중간 공백은 "글자 간격보다 확실히 크게"
        const minMidGap = Math.max(
          (fontEff + charGap) * 1.6,
          charGap * 3.0 + 1,
          fontEff * 1.2
        );
        if (midGap < minMidGap){
          midGap = minMidGap;
          continue;
        }

        // 이름 블록 높이(앵커): 3글자 템플릿 기반
        const nameBlockH = (Nanchor * fontEff) + (Nanchor - 1) * charGap;

        // ✅ "간격 축소 우선"은 CSS(space-between)가 자동 수행.
        //    다만 글자 높이 합이 nameBlockH보다 커지면(간격 0이어도 불가) 그때만 scale 축소
        const needH = Nraw * fontEff;

        if (needH <= nameBlockH + 0.01){
          // scale=1이면 여기로 대부분 들어오고, 4글자일 때 간격이 먼저 줄어듦
          // 최종 값 세팅 후 종료
          pageEl.style.setProperty('--text-scale', scale.toFixed(4));
          pageEl.style.setProperty('--member-body-h-px', bodyH.toFixed(2) + 'px');
          pageEl.style.setProperty('--char-gap-px', charGap.toFixed(2) + 'px');
          pageEl.style.setProperty('--small-gap-px', Math.max(0, charGap).toFixed(2) + 'px');
          pageEl.style.setProperty('--mid-gap-px', midGap.toFixed(2) + 'px');
          pageEl.style.setProperty('--name-block-h-px', nameBlockH.toFixed(2) + 'px');
          return;
        }

        // 여기부터는 "간격을 0까지 줄여도 부족"이므로 scale을 줄여야 함
        // scale 상한을 계산해 한번에 줄임(불필요한 과축소 방지)
        const A = Math.max(0, bodyH - midGap);

        // charGap>=0 조건: A - T*fontEff >= 0  => scale <= A/(T*fontBasePx)
        const scaleMaxNonNeg = (T > 0 && fontBasePx > 0) ? (A / (T * fontBasePx)) : 0.3;

        // fit 조건(needH<=nameBlockH)을 결합한 scale 상한(근사-안정)
        // 유도식 기반 상한: scale <= ((Nanchor-1)*A/D) / (fontBasePx * ((Nraw-Nanchor) + (Nanchor-1)*T/D))
        const denom = (Nraw - Nanchor) + ((Nanchor - 1) * T / D);
        let scaleMaxFit = 0.3;
        if (denom > 0 && fontBasePx > 0){
          scaleMaxFit = (((Nanchor - 1) * A / D) / (fontBasePx * denom));
        }

        const newScale = Math.max(0.25, Math.min(scale, 1, scaleMaxNonNeg, scaleMaxFit));

        if (Math.abs(newScale - scale) < 1e-4){
          scale = newScale;
          // 더 줄일 수 없으면(극단 케이스) 현재 값으로 강제 세팅 후 종료
          const fontEff2 = fontBasePx * scale;
          let charGap2 = (bodyH - midGap - (T * fontEff2)) / D;
          if (!isFinite(charGap2) || charGap2 < 0) charGap2 = 0;
          const nameBlockH2 = (Nanchor * fontEff2) + (Nanchor - 1) * charGap2;

          pageEl.style.setProperty('--text-scale', scale.toFixed(4));
          pageEl.style.setProperty('--member-body-h-px', bodyH.toFixed(2) + 'px');
          pageEl.style.setProperty('--char-gap-px', charGap2.toFixed(2) + 'px');
          pageEl.style.setProperty('--small-gap-px', Math.max(0, charGap2).toFixed(2) + 'px');
          pageEl.style.setProperty('--mid-gap-px', midGap.toFixed(2) + 'px');
          pageEl.style.setProperty('--name-block-h-px', nameBlockH2.toFixed(2) + 'px');
          return;
        }

        scale = newScale;
      }
    }

    function renderOnePage(gen){
      const members = Array.isArray(gen?.구성원) ? gen.구성원 : [];
      const location = gen?.위치 ?? '';
      const address  = gen?.주소 ?? '';

      const page = document.createElement('div');
      page.className = 'page';
      applyPreset(page, members.length);

      page.innerHTML = `
        <div class="pageInner">
          <div class="membersArea"></div>
          <div class="addrArea">
            <div class="addrLabel">주소</div>
            <div class="addrCols"></div>
          </div>
        </div>
      `;

      const membersAreaEl = page.querySelector('.membersArea');
      const addrColsEl = page.querySelector('.addrCols');

      buildMembers(membersAreaEl, members.slice(0,7), location);
      pagesEl.appendChild(page);

      requestAnimationFrame(() => {
        fitMembers(page);

        const initialAddrCols = buildAddressColumns(addrColsEl, address);
        autoAdjustAddrWidth(page, initialAddrCols);
        fitAddress(page, address);

        fitMembers(page);
        tuneMemberVerticalSpacing(page);
      });
    }

    function renderAll(gens){
      pagesEl.innerHTML = '';
      (Array.isArray(gens) ? gens : []).forEach(g => renderOnePage(g));
    }

    function renderFromState(){
      renderAll(state.gens);
      setStatus("미리보기 갱신 완료");
      setTimeout(() => setStatus(""), 1200);
    }

    // 입력 변경 시 자동 미리보기(디바운스)
    let renderTimer = null;
    function scheduleRender(){
      if (renderTimer) clearTimeout(renderTimer);
      renderTimer = setTimeout(() => renderFromState(), 250);
    }

    // -----------------------------
    // 초기화: ?src= 자동 로드
    // -----------------------------
    (async function init(){
      renderEditor();

      const p = new URLSearchParams(location.search);
      const src = p.get('src');
      if (src){
        urlEl.value = src;
        try{
          const obj = await loadFromUrl(src);
          importJsonObj(obj);
        }catch(err){
          console.error(err);
          renderFromState();
        }
      } else {
        renderFromState();
      }
    })();
  </script>
</body>
</html>
